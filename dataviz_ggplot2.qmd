---
title: "Visualisierung mit ggplot2"
subtitle: "Seminar[2] <- Data Wrangling, Desriptives & Visualisierung"
author: "Simon Krukowski"
format:
  html:
    code-fold: false
    code-summary: "Show code"
    df-print: paged
editor: visual
execute:
  freeze: true
---

```{r}
#| warning: false
#| code-fold: true
library(tidyverse)
library(reshape2)
library(reactable)

palette1 <- c("#648fff","#785ef0","#dc267f","#fe6100","#ffb000","#000000","#ffffff")
palette2 <- c("#CC79A7","#D55E00","#0072B2","#F0E442","#009E73","#56B4E9","#E69F00","#000000")

dataset <- read.csv("assets/datasets/iris.csv")
dataset$Species <- as.factor(dataset$Species)
```

# Data Visualisation: ggplot2

Wir wissen nun, wie wir mithilfe von `dplyr` schnell & effizient eine bessere Idee √ºber unsere Daten bekommen. Doch tabellarische Daten und einzelne Werte sind nur eine Seite der Data-Science Medaille: Besonders durch Datenvisualierung bekommen wir schnell eine Idee √ºber die Verteilung von Daten, und k√∂nnen versteckte Signale in den Daten enth√ºllen. Dazu eignet sich `ggplot2` hervorragend. Ebenso wie `dplyr` geh√∂rt `ggplot2` zu den beliebtesten R-Packages.

![How the author imagines how ggplot2 uncovers the world of knowledge](assets/img/ggplot2.png){alt="How the author imagines how ggplot2 uncovers the world of knowledge" fig-align="center" width="800"}

Ebenso wie `dplyr` sollte sich `ggplot2` automatisch durch die Installation von `tidyverse` installiert haben:

```{r}
#| eval: false
install.packages("tidyverse")
library(dplyr)
```

## Hintergrund

Base-R bietet nat√ºrlich auch Funktionen zur Visualisierung von Daten. Jedoch ist es auch hier hilfreich, gleich den "state-of-the-art" zu lernen und sich `ggplot2` anzueignen, da wir somit viel mehr Anpassungsm√∂glichkeiten, sowie eine vereinfachte Grammatik haben. Um dennoch etwas Kontext zu bieten, schauen wir uns illustrativ die `base`-R `hist()` Funktion an:

```{r}
hist(dataset$Sepal.Length)
```

Wir sehen, mit ganz wenig Code bietet `base`-R bereits eine Funktion zum erstellen von Histogrammen an. Das kann manchmal n√ºtzlich sein, bspw. wenn wir schnell einen √úberblick √ºber die Verteilung einer Variablen bekommen m√∂chten. Aus den oben genannten Gr√ºnden wollen wir an dieser Stelle aber den Fokus vor allem auf `ggplot2` setzen. Hinweis: `ggplot2` ist der offzielle Name und auch das richtige Package, der Einfachheit halber werden wir aber von `ggplot` sprechen.

## Syntax

Ebenso wie der Pipe-Operator `%>%` bei `dplyr` eine besondere Rolle spielt, tut es das `+` bei `ggplot`. Aber dazu gleich mehr. Im Folgenden sehen wir den grunds√§tzlichen Aufbau eines Befehls bzw. einer Befehlskette, die ein Plot erzeugt:

```{r}
#| eval: false

ggplot(data=object)+
  geom_function(aes(x=variable),parameters="xyz")+
  additional_functions(parameters="additionals")
```

Das sieht auf den ersten Blick erstmal komplizierter aus, als es ist. Aber wir werden den Code Schritt f√ºr Schritt aufschl√ºsseln.

### + Operator

Wie bereits erw√§hnt, spielt der `+` Operator eine wichtige Rolle bei `ggplot2`. Durch `+` k√∂nnen wir Befehle miteinander verketten. Wichtig zu verstehen ist, dass - √§hnlich wie bei `dplyr` - das Verketten von Befehlen dem "Stapeln" verschiedener Visualisierungen bzw. Eigenschaften entspricht, und jeder einzelne Schritt etwas zum finalen Plot beitr√§gt. Wie genau das abl√§uft, werden wir gleich am Beispiel des `iris` Datensatzes sehen.

### geom_function()

`geom_function()` (`geom_` f√ºr *geometrical*) ist hier nur ein Platzhalter f√ºr eine Vielzahl verschiedener Funktionen, die wir in Abh√§ngigkeit davon benutzen, was wir visualisieren wollen. So gibt es etwa `geom_bar()` f√ºr Bar-Charts, `geom_point()` f√ºr Punktwolken oder `geom_line()` f√ºr Liniendiagramme. Weiter unten werden wir einige davon beispielhaft vorstellen.

### aes()

`aes()` steht f√ºr *aesthetics* und sorgt daf√ºr, Datenpunkte in visuelle Darstellung zu √ºbertragen bzw. zu mappen. Das klingt erstmal abstrakter, als es eigentlich ist. Meistens werden hier die Variablen f√ºr die entsprechenden Achsen angebenen (bspw. `x=Sepal.Width`) oder aber auch f√ºr die Farben bzw. F√ºllungen von Balken/Punkten (bspw. `color=Species`). Warum das wichtig ist und was der Unterschied zu Parametern au√üerhalb der `aes()` Funktion ist, werden wir gleich sehen.

### Parameters

Wie bei allen Funktionen k√∂nnen wir hier auch diverse Dinge als Parameter √ºbergeben. Beispiele sind etwa `color` oder `size`.

### additional_functions()

Auch `additional_functions()` sind hier nur ein Platzhalter f√ºr eine Vielzahl weiterer Funktionen, die wir mit in unsere `ggplot` Kette nehmen k√∂nnen, bspw. `theme_classic()` oder `xlab()`. Mithilfe dieser k√∂nnen wir das Plot im Nachhinein weiter anpassen.

## Beispiel

Soweit die Syntax. Am besten l√§sst sich `ggplot` aber anhand eines Beispiels verstehen. Machen wir also mit unserem `iris` Datensatz weiter. Wir wollen die Verteilung der Blattgr√∂√üen besser verstehen, und entscheiden uns dazu, ein Plot mit `ggplot` zu erstellen. Wie bereits beschrieben, hilft der `+` Operator dabei, verschiedene Funktionen f√ºr das Plot miteinander zu verketten. Fangen wir also mit der ersten Ebene an:

```{r}
ggplot(data = dataset)
```

Wir sehen, mit dem Befehl `ggplot()` haben wir ein leeres Plot erzeugt. F√ºgen wir nun also ein Diagramm unserer Wahl hinzu. Wir fangen mit `geom_bar()` an.

```{r}
#| eval: false
ggplot(data = dataset)+
  geom_bar()
```

Wie wir sehen k√∂nnen, wirft R den Fehler :

```         
`stat_count()` requires an x or y aesthetic.
```

Das liegt daran, dass wir die `aes()` Funktion vergessen haben. Ohne das mapping von Datenpunkten wei√ü die `geom_bar()` Funktion nicht, wo welcher Datenpunkt hinsoll. Versuchen wir es also nochmal, und spezifizieren wir `Sepal.Width` als `x`-Variable:

```{r}
ggplot(data=dataset)+
  geom_bar(aes(x=Sepal.Width))
```

Wie wir sehen, haben wir nun die Variable `Sepal.Width` erfolgreich visualisiert und entdecken eine Normalverteilung.

Da es sich bei `geom_bar()` um ein Histogramm handelt, m√ºssen wir lediglich die `x`-Variable √ºbergeben, da f√ºr die `y`-Variable automatisch gez√§hlt wird.

Angenommen, wir m√∂chten die Farbe ver√§ndern, sodass die Balken die Farbe rot haben. Dann m√ºssen wir dies als `fill` Parameter der `geom_bar()` Funktion √ºbergeben:

```{r}
ggplot(data=dataset)+
  geom_bar(aes(x=Sepal.Width), fill="red")
```

Nun sind alle Balken rot. Was ist aber, wenn wir wollen, dass die Balken **in Abh√§ngigkeit einer Variable** verschiedenfarbig sind? Dann m√ºssen wir die `fill` Variable in der `aes()` Funktion √ºbergeben:

```{r}
ggplot(data=dataset)+
  geom_bar(aes(x=Sepal.Width, fill=Species))
```

Perfekt! Auf einen Blick k√∂nnen wir sehen, dass Pflanzen der Spezies `setosa`eher gr√∂√üere `Sepal.Width` haben. Bis jetzt haben wir allerdings nur einen Befehl mithilfe des `+` Operators verkn√ºpft. Angenommen, uns st√∂ren die Achsenbeschriftungen und wir wollen einen Titel haben. Auch das ist einfach m√∂glich:

```{r}
ggplot(data=dataset)+
  geom_bar(aes(x=Sepal.Width, fill=Species))+
  ylab("Prevalence")+
  xlab("Width of Sepal")+
  ggtitle("Sepal width of Iris Flower for each Species")
```

Die Farben sehen noch etwas langweilig aus. Ein kurzer Blick auf [**colorhunt.co**](https://colorhunt.co/palettes/popular) inspiriert uns und wir wollen nun die Farben `#9A208C`, `#E11299` und `#F5C6EC` als Farben haben. Das k√∂nnen wir √ºber `scale_fill_manual()` machen. Dazu speichern wir die Farben einfach in einen Vektor namens `palette` und √ºbergeben diesen als Parameter.

```{r}
palette <- c("#9A208C","#E11299","#F5C6EC")

ggplot(data=dataset)+
  geom_bar(aes(x=Sepal.Width, fill=Species))+
  ylab("Prevalence")+
  xlab("Width of Sepal")+
  ggtitle("Sepal width of Iris Flower for each Species")+
  scale_fill_manual(values = palette)
```

Wir h√§tten nun gerne noch einen schwarzen Rand um die Balken. Dabei hilft uns der Parameter `colour` in `geom_bar()`:

```{r}
ggplot(data=dataset)+
  geom_bar(aes(x=Sepal.Width, fill=Species), color="#2b2b2b")+
  ylab("Prevalence")+
  xlab("Width of Sepal")+
  ggtitle("Sepal width of Iris Flower for each Species")+
  scale_fill_manual(values = palette)
```

Jetzt st√∂rt uns nur noch der Hintergrund, und dann sind wir zufrieden. `ggplot` bietet verschiedene themes, die wir einfach √ºber den `+` Operator verwenden k√∂nnen. Wir entscheiden uns f√ºr `theme_classic()`:

```{r}
ggplot(data=dataset)+
  geom_bar(aes(x=Sepal.Width, fill=Species), color="#2b2b2b")+
  ylab("Prevalence")+
  xlab("Width of Sepal")+
  ggtitle("Sepal width of Iris Flower for each Species")+
  scale_fill_manual(values = palette)+
  theme_classic()
```

Super! Ein publizierf√§higes Plot in 7 Zeilen wiederverwendbarem Code. An diesem Beispiel haben wir gesehen, wie einfach das mit `ggplot` und das verketten von Befehlen geht. Im Folgenden wollen wir euch noch eine Auswahl an Visualisierungsfunktionen vorstellen, die wir h√§ufig ben√∂tigen.

## Visualisierungsfunktionen

Wie bereits beschrieben, sind `geom_` die Visualisierungsfunktionen. Jenachdem, wie unsere Daten strukturiert sind, bietet sich einige davon mehr, andere weniger an. Eine sinnvolle Einteilung geht **von den Achsen** bzw. **zu visualisierenden Variablen** aus. Dabei sollten wir uns immer die Frage stellen:

> Wieviele Variablen m√∂chte ich darstellen?

In einem 2-dimensionalen Koordinatensystem k√∂nnen wir nat√ºrlich erstmal nur zwei Variablen darstellen. Allerdings erlaubt uns `ggplot` auch die Visualisierung von mehr Variablen. So k√∂nnen wir etwa √ºber `fill` bzw. `colour` weitere Variablen visualieren. Eine weitere Frage, die wir uns in diese Richtung stellen sollten, ist:

> Was f√ºr einen Datentyp haben die zu visualisierenden Variablen?

Je nachdem, wie die wir diese Fragen beantworten, bieten sich dann verschiedene Funktionen an. Im obigen Beispiel haben wir **eine Variable** (`Sepal.Width)`**,** welche **intervall**skaliert ist. Daf√ºr bietet sich entsprechend ein Histogramm bzw. `geom_bar()`an. Doch was ist, wenn wir **zwei intervallskalierte** Variablen haben? Hier k√∂nnten wir bspw. die `geom_point()` Funktion benutzen. F√ºr solche Fragestellungen kann das **ggplot Cheatsheet** sehr hilfreich sein:

[![](assets/img/ggplot_cheatsheet.png){fig-align="center" width="300"}](https://github.com/rstudio/cheatsheets/blob/main/data-visualization.pdf)

Neben geom_bar wollen wir zwei weitere, h√§ufig ben√∂tigte Funktionen, sowie deren Kombination zeigen: `geom_point()` und `geom_smooth()`.

### geom_point()

Angenommen, wir haben zwei intervallskalierte Variablen, die wir visualisieren wollen. Dann bietet sich `geom_point()` an. Versuchen wir also mal, die Verteilung von `Sepal.Width` und `Sepal.Length` zu visualisieren.

```{r}
ggplot(data=dataset)+
  geom_point(aes(x=Sepal.Width,y=Sepal.Length))
```

Super! Nun w√§re es praktisch, wenn wir auch noch die Variable `Species` einbringen k√∂nnten. Dies k√∂nnen wir durch `colour` in `aes()` tun.

```{r}
ggplot(data=dataset)+
  geom_point(aes(x=Sepal.Width,y=Sepal.Length,color=Species))
```

Auch hier sehen wir direkt, dass es einen Unterschied zwischen den verschiedenen Spezies zu geben scheint. Visuell k√∂nnen wir auch den (offensichtlichen) Zusammenhang zwischen `Sepal.Width` und `Sepal.Length` erkennen. Um das aber noch etwas besser zu verstehen, legen wir eine Regressionsgrade mithilfe von `geom_smooth()` rein. Das k√∂nnen wir √ºber den `+` Operator tun - denn in `ggplot` k√∂nnen wir alle Visualisierungsfunktionen nach Belieben "stapeln".

```{r}
ggplot(data=dataset)+
  geom_point(aes(x=Sepal.Width,y=Sepal.Length,color=Species))+
  geom_smooth(aes(x=Sepal.Width,y=Sepal.Length), method="lm") # lm for linear model
```

Die Regressionsgrade zeigt einen negativen Zusammenhang, obwohl wir offensichtlich einen positiven Zusammenhang vorliegen haben. Das liegt daran, dass `geom_smooth()` unseren Faktor `Species` nicht ber√ºcksichtigt. Dies k√∂nnen wir √§ndern, indem wir in dessen `aes()` Funktion ebenfalls `colour` √ºbergeben.

```{r}
#| warning: false
ggplot(data=dataset)+
  geom_point(aes(x=Sepal.Width,y=Sepal.Length,colour=Species))+
  geom_smooth(aes(x=Sepal.Width,y=Sepal.Length, colour=Species), method="lm") # lm for linear model
```

Voila! Wir sehen unsere drei kleinen Regressionsgraden und den erwarteten positiven Zusammenhang.

## Fazit & Weitere Resourcen

Wir haben nun gelernt, wie wir mithilfe von `ggplot` Daten visualisieren k√∂nnen. Nat√ºrlich war das nur die Spitze des Eisbergs, und noch viel mehr ist m√∂glich. Einige dieser Dinge werden wir im weiteren Verlauf des Seminars kennenlernen, wenn es um das Arbeiten (und Visualisieren) von konkreten Datens√§tzen geht. Im Laufe des Seminars werden wir auch eine eigene "nice to know" Seite erstellen, auf der wir zus√§tzliches Wissen sammeln.

Neben dieser Website hier (ü•≥) gibt es nat√ºrlich noch viele weitere, tolle Resourcen im Internet. Neben den offziellen Dokumentationen bspw. auf tidyverse oder CRAN wollen wir euch vor allem mit Blick auf `dplyr` und `ggplot` noch einige ans ‚ù§Ô∏è legen:

-   [**sthda.com**](http://www.sthda.com/english/wiki/be-awesome-in-ggplot2-a-practical-guide-to-be-highly-effective-r-software-and-data-visualization)**:** Be Awesome in ggplot2: A Practical Guide to be Highly Effective - R software and data visualization

-   [**r-graph-gallery.com**](https://r-graph-gallery.com/index.html): A collection of charts made with the R programming language

-   [**r-bloggers.com**](https://www.r-bloggers.com/2018/05/dplyr-a-beginners-guide/): DPLYR: A beginner's guide
